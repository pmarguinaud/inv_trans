MODULE FIELD_MODULE

IMPLICIT NONE

TYPE FIELD_BASIC

END TYPE

TYPE FIELD_BASIC_PTR
  CLASS (FIELD_BASIC), POINTER :: PTR
END TYPE

TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_1RB
  REAL, POINTER :: P (:)
CONTAINS
  PROCEDURE :: GET_DIMS => GET_DIMS_1RB
END TYPE

TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_2RB
  REAL, POINTER :: P (:,:)
CONTAINS
  PROCEDURE :: GET_DIMS => GET_DIMS_2RB
END TYPE

TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_3RB
  REAL, POINTER :: P (:,:,:)
CONTAINS
  PROCEDURE :: GET_DIMS => GET_DIMS_3RB
END TYPE

TYPE FIELD_1RB_VIEW
  REAL, POINTER :: V (:)
END TYPE

TYPE FIELD_2RB_VIEW
  REAL, POINTER :: V (:,:)
END TYPE

INTERFACE B
  MODULE PROCEDURE :: B1RB, B2RB, B3RB
END INTERFACE

INTERFACE FIELD_NEW
  MODULE PROCEDURE :: FIELD_NEW_1RB, FIELD_NEW_2RB, FIELD_NEW_3RB
END INTERFACE

CONTAINS

SUBROUTINE GET_DIMS_1RB (SELF, LBOUNDS, UBOUNDS)
CLASS (FIELD_1RB) :: SELF
INTEGER, OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
END SUBROUTINE

SUBROUTINE GET_DIMS_2RB (SELF, LBOUNDS, UBOUNDS)
CLASS (FIELD_2RB) :: SELF
INTEGER, OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
END SUBROUTINE

SUBROUTINE GET_DIMS_3RB (SELF, LBOUNDS, UBOUNDS)
CLASS (FIELD_3RB) :: SELF
INTEGER, OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
END SUBROUTINE

FUNCTION B1RB (YLF)

CLASS (FIELD_1RB), POINTER :: YLF
TYPE (FIELD_BASIC_PTR) :: B1RB

B1RB%PTR => YLF

END FUNCTION

FUNCTION B2RB (YLF)

CLASS (FIELD_2RB), POINTER :: YLF
TYPE (FIELD_BASIC_PTR) :: B2RB

B2RB%PTR => YLF

END FUNCTION

FUNCTION B3RB (YLF)

CLASS (FIELD_3RB), POINTER :: YLF
TYPE (FIELD_BASIC_PTR) :: B3RB

B3RB%PTR => YLF

END FUNCTION

SUBROUTINE FIELD_NEW_1RB (YLF, UBOUNDS)

CLASS (FIELD_1RB), POINTER :: YLF
INTEGER :: UBOUNDS (1)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1)))

END SUBROUTINE

SUBROUTINE FIELD_NEW_2RB (YLF, UBOUNDS)

CLASS (FIELD_2RB), POINTER :: YLF
INTEGER :: UBOUNDS (2)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2)))

END SUBROUTINE

SUBROUTINE FIELD_NEW_3RB (YLF, UBOUNDS)

CLASS (FIELD_3RB), POINTER :: YLF
INTEGER :: UBOUNDS (3)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2), UBOUNDS (3)))

END SUBROUTINE

FUNCTION LG2RB (YLF, LDACC)

CLASS (FIELD_2RB), POINTER, INTENT (IN) :: YLF
LOGICAL, OPTIONAL :: LDACC

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG2RB (:)

REAL, POINTER :: ZZ2 (:,:)
INTEGER :: I2, I3, J

ZZ2 => YLF%P

ALLOCATE (LG2RB (1))

LG2RB (1)%V => ZZ2

END FUNCTION

FUNCTION LG3RB (YLF, LDACC)

CLASS (FIELD_3RB), POINTER, INTENT (IN) :: YLF
LOGICAL, OPTIONAL :: LDACC

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG3RB (:)

REAL, POINTER :: ZZ3 (:,:,:)
INTEGER :: I2, J

ZZ3 => YLF%P

ALLOCATE (LG3RB (SIZE (ZZ3, 2)))

J = 1

DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
  LG3RB (J)%V => ZZ3 (:, I2, :)
  J = J + 1
ENDDO

END FUNCTION

FUNCTION LG (YLFL, LDACC)

TYPE (FIELD_BASIC_PTR) :: YLFL (:)
LOGICAL, OPTIONAL :: LDACC

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG (:)

INTEGER :: IOFF, ILEN, JFLD, JPASS
INTEGER :: ILBOUNDS (5), IUBOUNDS (5)

DO JPASS = 1, 2

  IOFF = 0
  
  DO JFLD = 1, SIZE (YLFL)
  
    SELECT TYPE (YLF => YLFL (JFLD)%PTR)
      CLASS IS (FIELD_2RB)
        CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
        ILEN = 1
        IF (JPASS == 2) LG (IOFF+1:IOFF+ILEN) = LG2RB (YLF, LDACC)
      CLASS IS (FIELD_3RB)
        CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
        ILEN = (IUBOUNDS (2) - ILBOUNDS (2) + 1)
        IF (JPASS == 2) LG (IOFF+1:IOFF+ILEN) = LG3RB (YLF, LDACC)
      CLASS DEFAULT
        STOP 1
    END SELECT

    IOFF = IOFF + ILEN
  
  ENDDO

  IF (JPASS == 1) THEN
    ALLOCATE (LG (IOFF))
  ENDIF

ENDDO

END FUNCTION LG

FUNCTION LS1RB (YLF, LDACC)

CLASS (FIELD_1RB), POINTER, INTENT (IN) :: YLF
LOGICAL, OPTIONAL :: LDACC

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS1RB (:)

REAL, POINTER :: ZZ1 (:)

ZZ1 => YLF%P

ALLOCATE (LS1RB (1))

LS1RB (1)%V => ZZ1 

END FUNCTION

FUNCTION LS2RB (YLF, LDACC)

CLASS (FIELD_2RB), POINTER, INTENT (IN) :: YLF
LOGICAL, OPTIONAL :: LDACC

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS2RB (:)

REAL, POINTER :: ZZ2 (:,:)
INTEGER :: I2, I3, J

ZZ2 => YLF%P

ALLOCATE (LS2RB (SIZE (ZZ2, 2)))

J = 1

DO I2 = LBOUND (ZZ2, 2), UBOUND (ZZ2, 2)
  LS2RB (J)%V => ZZ2 (:, I2)
  J = J + 1
ENDDO

END FUNCTION

FUNCTION LS3RB (YLF, LDACC)

CLASS (FIELD_3RB), POINTER, INTENT (IN) :: YLF
LOGICAL, OPTIONAL :: LDACC

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS3RB (:)

REAL, POINTER :: ZZ3 (:,:,:)
INTEGER :: I2, I3, J

ZZ3 => YLF%P

ALLOCATE (LS3RB (SIZE (ZZ3, 2) * SIZE (ZZ3, 3)))

J = 1

DO I3 = LBOUND (ZZ3, 3), UBOUND (ZZ3, 3)
  DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
    LS3RB (J)%V => ZZ3 (:, I2, I3)
    J = J + 1
  ENDDO
ENDDO

END FUNCTION

FUNCTION LS (YLFL, LDACC)

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS (:)
LOGICAL, OPTIONAL :: LDACC

TYPE (FIELD_BASIC_PTR) :: YLFL (:)
INTEGER :: IOFF, ILEN, JFLD, JPASS
INTEGER :: ILBOUNDS (5), IUBOUNDS (5)

DO JPASS = 1, 2

  IOFF = 0
  
  DO JFLD = 1, SIZE (YLFL)
  
    SELECT TYPE (YLF => YLFL (JFLD)%PTR)
      CLASS IS (FIELD_1RB)
        ILEN = 1
        IF (JPASS == 2) LS (IOFF+1:IOFF+ILEN) = LS1RB (YLF, LDACC)
      CLASS IS (FIELD_2RB)
        CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
        ILEN = (IUBOUNDS (2) - ILBOUNDS (2) + 1)
        IF (JPASS == 2) LS (IOFF+1:IOFF+ILEN) = LS2RB (YLF, LDACC)
      CLASS DEFAULT
        STOP 1
    END SELECT

    IOFF = IOFF + ILEN
  
  ENDDO

  IF (JPASS == 1) THEN
    ALLOCATE (LS (IOFF))
  ENDIF

ENDDO

END FUNCTION LS

END MODULE

MODULE INV_TRANS_MODULE

USE FIELD_MODULE

IMPLICIT NONE

ABSTRACT INTERFACE

SUBROUTINE FSPGL_INTF (KM,KSL,KDGL,KFIELDS,PR1MU2,PFIELD,&
                     & KPTRU,KFLDUV,KFLDSC,KFLDPTRUV)

PARAMETER (JPIM = 4, JPRB = 4)

INTEGER(KIND=JPIM),INTENT(IN)           :: KM
INTEGER(KIND=JPIM),INTENT(IN)           :: KSL
INTEGER(KIND=JPIM),INTENT(IN)           :: KDGL
REAL(KIND=JPRB)   ,INTENT(IN)           :: PR1MU2(KDGL)
INTEGER(KIND=JPIM),INTENT(IN)           :: KFIELDS
REAL(KIND=JPRB)   ,INTENT(INOUT),TARGET :: PFIELD(2*KFIELDS,0:KDGL+1)
INTEGER(KIND=JPIM),INTENT(IN)           :: KPTRU
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDUV
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDSC
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDPTRUV(KFLDUV)

END SUBROUTINE FSPGL_INTF

END INTERFACE

CONTAINS

SUBROUTINE INV_TRANS_ (PSPVOR, PSPDIV, PGPUV, KVSETUV, PSPSCALAR, PGP, KVSETSC, KPROMA, FSPGL_PROC)

INTEGER, PARAMETER :: JPIM = 4, JPRB = 4

REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPVOR(:,:)
REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPDIV(:,:)
REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSCALAR(:,:)
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
EXTERNAL  FSPGL_PROC
OPTIONAL  FSPGL_PROC
REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP(:,:,:)
REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGPUV(:,:,:,:)

END SUBROUTINE INV_TRANS_

SUBROUTINE INV_TRANS (U, V, VOR, DIV, VSETUV, GRID, SPEC, VSET, LDACC, FSPGL_PROC)

TYPE (FIELD_BASIC_PTR), OPTIONAL :: U (:), V (:), GRID (:)
TYPE (FIELD_BASIC_PTR), OPTIONAL :: VOR (:), DIV (:), SPEC (:)
INTEGER, OPTIONAL :: VSETUV (:), VSET (:)
LOGICAL, OPTIONAL :: LDACC
PROCEDURE (FSPGL_INTF), OPTIONAL :: FSPGL_PROC

REAL, ALLOCATABLE :: ZGPUV (:,:,:,:), ZSPVOR (:,:), ZSPDIV (:,:), ZGP (:,:,:), ZSPSCALAR (:,:)
INTEGER :: IPROMA, IGPBLKS, IFLDGUV, ISPEC2, IFLDSUV, IFLDG, JFLD, IFLDS

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: UL (:), VL (:), GRIDL (:)
TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: VORL (:), DIVL (:), SPECL (:)


IF (PRESENT (U) .NEQV. PRESENT (V)) STOP "U/V"
IF (PRESENT (U) .NEQV. PRESENT (VOR)) STOP "U/VOR"
IF (PRESENT (U) .NEQV. PRESENT (DIV)) STOP "U/DIV"
IF (PRESENT (U) .NEQV. PRESENT (VSETUV)) STOP "U/VSETUV"

IF (PRESENT (U)) THEN

  IF ((SIZE (U) /= SIZE (V)) .OR. (SIZE (U) /= SIZE (DIV)) .OR. (SIZE (U) /= SIZE (VOR))) THEN
    PRINT *, " U = ", SIZE (U)
    PRINT *, " V = ", SIZE (V)
    PRINT *, " VOR = ", SIZE (VOR)
    PRINT *, " DIV = ", SIZE (DIV)
    STOP 1
  ENDIF

  VORL = LS (VOR, LDACC)
  DIVL = LS (DIV, LDACC)

  UL = LG (U)
  VL = LG (V)

  IF ((SIZE (UL) /= SIZE (VL)) .OR. (SIZE (VORL) /= SIZE (DIVL)) .OR. (SIZE (UL) /= SIZE (VSETUV))) THEN
    PRINT *, " UL = ", SIZE (UL)
    PRINT *, " VL = ", SIZE (VL)
    PRINT *, " VORL = ", SIZE (VORL)
    PRINT *, " DIVL = ", SIZE (DIVL)
    PRINT *, " VSETUV = ", SIZE (VSETUV)
    STOP 1
  ENDIF

  IPROMA = SIZE (UL (1)%V, 1)
  IGPBLKS = SIZE (UL (1)%V, 2) 
  IFLDGUV = SIZE (UL)

  ISPEC2 = SIZE (VORL (1)%V, 1)
  IFLDSUV = SIZE (VORL)

  ALLOCATE (ZGPUV (IPROMA, IFLDGUV, 2, IGPBLKS), ZSPVOR (ISPEC2, IFLDSUV), ZSPDIV (ISPEC2, IFLDSUV))

  DO JFLD = 1, IFLDSUV
    ZSPVOR (:, JFLD) = VORL (JFLD)%V (:)
    ZSPDIV (:, JFLD) = DIVL (JFLD)%V (:)
  ENDDO

ELSE

  IFLDSUV = 0
  ALLOCATE (ZGPUV (0, IFLDSUV, 2, 0), ZSPVOR (0, 0), ZSPDIV (0, 0))

ENDIF

IF (PRESENT (GRID) .NEQV. PRESENT (SPEC)) STOP "GRID/SPEC"
IF (PRESENT (GRID) .NEQV. PRESENT (VSET)) STOP "GRID/VSET"

IF (PRESENT (GRID)) THEN

  IF (SIZE (GRID) /= SIZE (SPEC)) THEN
    PRINT *, " SIZE (GRID) = ", SIZE (GRID)
    PRINT *, " SIZE (SPEC) = ", SIZE (SPEC)
    STOP 1
  ENDIF

  GRIDL = LG (GRID, LDACC)
  SPECL = LS (SPEC, LDACC)

  IF (SIZE (GRIDL) /= SIZE (VSET)) THEN
    PRINT *, " SIZE (GRIDL) = ", SIZE (GRIDL)
    PRINT *, " SIZE (SPECL) = ", SIZE (SPECL)
    PRINT *, " SIZE (VSET) = ", SIZE (VSET)
    STOP 1
  ENDIF

  IPROMA = SIZE (GRIDL (1)%V, 1)
  IGPBLKS = SIZE (GRIDL (1)%V, 2)
  IFLDG = SIZE (GRIDL)

  ISPEC2 = SIZE (SPECL (1)%V, 1)
  IFLDS = SIZE (SPECL)

  ALLOCATE (ZGP (IPROMA, IFLDG, IGPBLKS), ZSPSCALAR (ISPEC2, IFLDS))

  DO JFLD = 1, IFLDS
    ZSPSCALAR (:,JFLD) = SPECL (JFLD)%V (:)
  ENDDO

ELSE

  IFLDG = 0
  ALLOCATE (ZGP (0, IFLDG, 0), ZSPSCALAR (0, 0))

ENDIF

IF (PRESENT (FSPGL_PROC)) THEN
  CALL INV_TRANS_ (PSPVOR=ZSPVOR, PSPDIV=ZSPDIV, PGPUV=ZGPUV, KVSETUV=VSETUV, &
                 & PSPSCALAR=ZSPSCALAR, PGP=ZGP, KVSETSC=VSET, KPROMA=IPROMA, &
                 & FSPGL_PROC=FSPGL_PROC)
ELSE
  CALL INV_TRANS_ (PSPVOR=ZSPVOR, PSPDIV=ZSPDIV, PGPUV=ZGPUV, KVSETUV=VSETUV, &
                 & PSPSCALAR=ZSPSCALAR, PGP=ZGP, KVSETSC=VSET, KPROMA=IPROMA)
ENDIF

DO JFLD = 1, IFLDGUV
  UL (JFLD)%V (:,:) = ZGPUV (:,JFLD,1,:)
  VL (JFLD)%V (:,:) = ZGPUV (:,JFLD,2,:)
ENDDO

DO JFLD = 1, IFLDG
  GRIDL (JFLD)%V (:,:) = ZGP (:, JFLD, :)
ENDDO

END SUBROUTINE

END MODULE

PROGRAM MAIN

USE FIELD_MODULE
USE INV_TRANS_MODULE

INTEGER, PARAMETER :: NPRTRW = 5, NPRTRV = 3, MYSETW = 1, MYSETV = 1

INTEGER, PARAMETER :: NPROMA = 100, NFLEVG = 15, NGPBLKS = 10, NSPEC2 = 600
INTEGER :: NFLEVL 

CLASS (FIELD_3RB), POINTER :: GU, GV, GT, GQ
CLASS (FIELD_2RB), POINTER :: SVOR, SDIV, ST, SQ

CLASS (FIELD_2RB), POINTER :: GU1, GV1, GT1, GQ1
CLASS (FIELD_1RB), POINTER :: SVOR1, SDIV1, ST1, SQ1

TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: U (:), V (:), GRID (:)
TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: VOR (:), DIV (:), SPEC (:)

INTEGER :: NBSETP
INTEGER, ALLOCATABLE :: NBSETLEV (:)
INTEGER, ALLOCATABLE :: VSETUV (:), VSET (:)

PROCEDURE (FSPGL_INTF), POINTER :: FSPGL_PROC => NULL ()

LOGICAL :: LLACC

INTEGER :: JLEV

NBSETSP = 1

ALLOCATE (NBSETLEV (NFLEVG))

DO JLEV = 1, NFLEVG
  NBSETLEV (JLEV) = 1 + ((JLEV-1) * (NPRTRV)) / NFLEVG
ENDDO

NFLEVL = COUNT (NBSETLEV == MYSETV)

CALL FIELD_NEW (GU, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GV, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GT, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GQ, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])

CALL FIELD_NEW (SVOR, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SDIV, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (ST, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SQ, UBOUNDS=[NSPEC2, NFLEVL])

CALL FIELD_NEW (GU1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GV1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GT1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GQ1, UBOUNDS=[NPROMA, NGPBLKS])

CALL FIELD_NEW (SVOR1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW (SDIV1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW (ST1, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SQ1, UBOUNDS=[NSPEC2, NFLEVL])


! Create list arguments

FSPGL_PROC => NULL ()

CALL INV_TRANS (U=[B (GU), B (GU1)], VOR=[B (SVOR), B (SVOR1)], &
              & V=[B (GV), B (GV1)], DIV=[B (SDIV), B (SDIV1)], &
              & VSETUV=[NBSETLEV, NBSETSP], &
              & GRID=[B (GT), B (GQ), B (GT1), B (GQ1)], &
              & SPEC=[B (ST), B (SQ), B (ST1), B (SQ1)], &
              & VSET=[NBSETLEV, NBSETLEV, NBSETSP, NBSETSP], &
              & LDACC=LLACC, FSPGL_PROC=FSPGL_PROC) !  FSPGL_PROC not PRESENT, because it is NULL associated

! Build list

U = [B (GU), B (GU1)]
V = [B (GV), B (GV1)]

VOR = [B (SVOR), B (SVOR1)]
DIV = [B (SDIV), B (SDIV1)]

VSETUV = [NBSETLEV, NBSETSP]

GRID = [B (GT), B (GQ), B (GT1), B (GQ1)]
SPEC = [B (ST), B (SQ), B (ST1), B (SQ1)]
VSET = [NBSETLEV, NBSETLEV, NBSETSP, NBSETSP]

CALL INV_TRANS (U=U, V=V, VOR=VOR, DIV=DIV, VSETUV=VSETUV, &
              & GRID=GRID, SPEC=SPEC, VSET=VSET, LDACC=LLACC)

! Build list in two steps

! First step : 3D fields

U = [B (GU)]
V = [B (GV)]

VOR = [B (SVOR)]
DIV = [B (SDIV)]

VSETUV = [NBSETLEV]

GRID = [B (GT), B (GQ)]
SPEC = [B (ST), B (SQ)]

! Append surface fields

U = [U, B (GU1)]
V = [V, B (GV1)]

VOR = [VOR, B (SVOR1)]
DIV = [DIV, B (SDIV1)]
VSETUV = [VSETUV, NBSETSP]

GRID = [GRID, B (GT1), B (GQ1)]
SPEC = [SPEC, B (ST1), B (SQ1)]

FSPGL_PROC => FSPGL

CALL INV_TRANS (U=U, V=V, VOR=VOR, DIV=DIV, VSETUV=VSETUV, &
              & GRID=GRID, SPEC=SPEC, VSET=VSET, LDACC=LLACC, &
              & FSPGL_PROC=FSPGL_PROC)

CONTAINS

SUBROUTINE FSPGL (KM,KSL,KDGL,KFIELDS,PR1MU2,PFIELD,&
                & KPTRU,KFLDUV,KFLDSC,KFLDPTRUV)

PARAMETER (JPIM = 4, JPRB = 4)

INTEGER(KIND=JPIM),INTENT(IN)           :: KM
INTEGER(KIND=JPIM),INTENT(IN)           :: KSL
INTEGER(KIND=JPIM),INTENT(IN)           :: KDGL
REAL(KIND=JPRB)   ,INTENT(IN)           :: PR1MU2(KDGL)
INTEGER(KIND=JPIM),INTENT(IN)           :: KFIELDS
REAL(KIND=JPRB)   ,INTENT(INOUT),TARGET :: PFIELD(2*KFIELDS,0:KDGL+1)
INTEGER(KIND=JPIM),INTENT(IN)           :: KPTRU
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDUV
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDSC
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDPTRUV(KFLDUV)

END SUBROUTINE FSPGL

END 

