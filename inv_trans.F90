MODULE FIELD_MODULE

IMPLICIT NONE

TYPE FIELD_BASIC

END TYPE

TYPE FIELD_BASIC_PTR
  CLASS (FIELD_BASIC), POINTER :: PTR
END TYPE

TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_1RB
  REAL, POINTER :: P (:)
CONTAINS
  PROCEDURE :: GET_DIMS => GET_DIMS_1RB
END TYPE

TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_2RB
  REAL, POINTER :: P (:,:)
CONTAINS
  PROCEDURE :: GET_DIMS => GET_DIMS_2RB
END TYPE

TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_3RB
  REAL, POINTER :: P (:,:,:)
CONTAINS
  PROCEDURE :: GET_DIMS => GET_DIMS_3RB
END TYPE

TYPE FIELD_1RB_VIEW
  REAL, POINTER :: V (:)
END TYPE

TYPE FIELD_2RB_VIEW
  REAL, POINTER :: V (:,:)
END TYPE

INTERFACE B
  MODULE PROCEDURE :: B1RB, B2RB, B3RB
END INTERFACE

INTERFACE FIELD_NEW
  MODULE PROCEDURE :: FIELD_NEW_1RB, FIELD_NEW_2RB, FIELD_NEW_3RB
END INTERFACE

CONTAINS

SUBROUTINE GET_DIMS_1RB (SELF, LBOUNDS, UBOUNDS)
CLASS (FIELD_1RB) :: SELF
INTEGER, OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
END SUBROUTINE

SUBROUTINE GET_DIMS_2RB (SELF, LBOUNDS, UBOUNDS)
CLASS (FIELD_2RB) :: SELF
INTEGER, OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
END SUBROUTINE

SUBROUTINE GET_DIMS_3RB (SELF, LBOUNDS, UBOUNDS)
CLASS (FIELD_3RB) :: SELF
INTEGER, OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
END SUBROUTINE

FUNCTION B1RB (YLF)

CLASS (FIELD_1RB), POINTER :: YLF
TYPE (FIELD_BASIC_PTR) :: B1RB

B1RB%PTR => YLF

END FUNCTION

FUNCTION B2RB (YLF)

CLASS (FIELD_2RB), POINTER :: YLF
TYPE (FIELD_BASIC_PTR) :: B2RB

B2RB%PTR => YLF

END FUNCTION

FUNCTION B3RB (YLF)

CLASS (FIELD_3RB), POINTER :: YLF
TYPE (FIELD_BASIC_PTR) :: B3RB

B3RB%PTR => YLF

END FUNCTION

SUBROUTINE FIELD_NEW_1RB (YLF, UBOUNDS)

CLASS (FIELD_1RB), POINTER :: YLF
INTEGER :: UBOUNDS (1)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1)))

END SUBROUTINE

SUBROUTINE FIELD_NEW_2RB (YLF, UBOUNDS)

CLASS (FIELD_2RB), POINTER :: YLF
INTEGER :: UBOUNDS (2)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2)))

END SUBROUTINE

SUBROUTINE FIELD_NEW_3RB (YLF, UBOUNDS)

CLASS (FIELD_3RB), POINTER :: YLF
INTEGER :: UBOUNDS (3)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2), UBOUNDS (3)))

END SUBROUTINE

FUNCTION LG2RB (YLF)

CLASS (FIELD_2RB), POINTER :: YLF

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG2RB (:)

REAL, POINTER :: ZZ2 (:,:)
INTEGER :: I2, I3, J

ZZ2 => YLF%P

ALLOCATE (LG2RB (1))

LG2RB (1)%V => ZZ2

END FUNCTION

FUNCTION LG3RB (YLF)

CLASS (FIELD_3RB), POINTER :: YLF

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG3RB (:)

REAL, POINTER :: ZZ3 (:,:,:)
INTEGER :: I2, J

ZZ3 => YLF%P

ALLOCATE (LG3RB (SIZE (ZZ3, 2)))

J = 1

DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
  LG3RB (J)%V => ZZ3 (:, I2, :)
  J = J + 1
ENDDO

END FUNCTION

!FUNCTION LG (YLFL)

!TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG (:)

!CLASS (FIELD_BASIC_PTR), POINTER :: YLFL

!SELECT TYPE (YLF => YLFL%PTR)
!  CLASS IS (FIELD_2RB)
!    LG = LG2RB (YLF)
!  CLASS IS (FIELD_3RB)
!    LG = LG3RB (YLF)
!  CLASS DEFAULT
!    STOP 1
!END SELECT

!END FUNCTION LG

FUNCTION LS1RB (YLF)

CLASS (FIELD_1RB), POINTER, INTENT (IN) :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS1RB (:)

REAL, POINTER :: ZZ1 (:)

ZZ1 => YLF%P

ALLOCATE (LS1RB (1))

LS1RB (1)%V => ZZ1 

END FUNCTION

FUNCTION LS2RB (YLF)

CLASS (FIELD_2RB), POINTER, INTENT (IN) :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS2RB (:)

REAL, POINTER :: ZZ2 (:,:)
INTEGER :: I2, I3, J

ZZ2 => YLF%P

ALLOCATE (LS2RB (SIZE (ZZ2, 2)))

J = 1

DO I2 = LBOUND (ZZ2, 2), UBOUND (ZZ2, 2)
  LS2RB (J)%V => ZZ2 (:, I2)
  J = J + 1
ENDDO

END FUNCTION

FUNCTION LS3RB (YLF)

CLASS (FIELD_3RB), POINTER, INTENT (IN) :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS3RB (:)

REAL, POINTER :: ZZ3 (:,:,:)
INTEGER :: I2, I3, J

ZZ3 => YLF%P

ALLOCATE (LS3RB (SIZE (ZZ3, 2) * SIZE (ZZ3, 3)))

J = 1

DO I3 = LBOUND (ZZ3, 3), UBOUND (ZZ3, 3)
  DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
    LS3RB (J)%V => ZZ3 (:, I2, I3)
    J = J + 1
  ENDDO
ENDDO

END FUNCTION

FUNCTION LS (YLFL)

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS (:)

TYPE (FIELD_BASIC_PTR) :: YLFL (:)
CLASS (FIELD_BASIC), POINTER :: YLFB
INTEGER :: IOFF, ILEN, JFLD, JPASS
INTEGER :: ILBOUNDS (5), IUBOUNDS (5)

DO JPASS = 1, 2

  IOFF = 0
  
  DO JFLD = 1, SIZE (YLFL)
  
    YLFB => YLFL (JFLD)%PTR
  
    SELECT TYPE (YLF => YLFB)
      CLASS IS (FIELD_1RB)
        ILEN = 1
        IF (JPASS == 2) LS (IOFF+1:IOFF+ILEN) = LS1RB (YLF)
      CLASS IS (FIELD_2RB)
        CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
        ILEN = (IUBOUNDS (2) - ILBOUNDS (2) + 1)
        IF (JPASS == 2) LS (IOFF+1:IOFF+ILEN) = LS2RB (YLF)
      CLASS DEFAULT
        STOP 1
    END SELECT

    IOFF = IOFF + ILEN
  
  ENDDO

  IF (JPASS == 1) THEN
    ALLOCATE (LS (ISIZE))
  ENDIF

ENDDO

END FUNCTION LS

END MODULE

MODULE INV_TRANS_MODULE

USE FIELD_MODULE

CONTAINS

SUBROUTINE INV_TRANS (U, V, VOR, DIV, VSETUV, GRID, SPEC, VSET)

TYPE (FIELD_BASIC_PTR), OPTIONAL :: U (:), V (:), GRID (:)
TYPE (FIELD_BASIC_PTR), OPTIONAL :: VOR (:), DIV (:), SPEC (:)
INTEGER, OPTIONAL :: VSETUV (:), VSET (:)

REAL, ALLOCATABLE :: ZGPUV (:,:,:,:), ZSPVOR (:,:), ZSPDIV (:,:), ZGP (:,:,:), ZSPSCALAR (:,:)
INTEGER :: IPROMA, IGPBLKS, IFLDGUV, ISPEC2, IFLDSUV

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: UL (:), VL (:), GRIDL (:)
TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: VORL (:), DIVL (:), SPECL (:)


IF (PRESENT (U) .NEQV. PRESENT (V)) STOP "U/V"
IF (PRESENT (U) .NEQV. PRESENT (VOR)) STOP "U/VOR"
IF (PRESENT (U) .NEQV. PRESENT (DIV)) STOP "U/DIV"
IF (PRESENT (U) .NEQV. PRESENT (VSETUV)) STOP "U/VSETUV"

IF (PRESENT (U)) THEN

  IF ((SIZE (U) /= SIZE (V)) .OR. (SIZE (VOR) /= SIZE (DIV))) THEN
    PRINT *, " U = ", SIZE (U)
    PRINT *, " V = ", SIZE (V)
    PRINT *, " VOR = ", SIZE (VOR)
    PRINT *, " DIV = ", SIZE (DIV)
    STOP 1
  ENDIF

  VORL = LS (VOR)

! IPROMA = SIZE (U (1)%V, 1)
! IGPBLKS = SIZE (U (1)%V, 2) 
! IFLDGUV = SIZE (U)

! ISPEC2 = SIZE (VOR (1)%V, 1)
! IFLDSUV = SIZE (VOR)

! ALLOCATE (ZGPUV (IPROMA, IFLDGUV, 2, IGPBLKS), ZSPVOR (ISPEC2, IFLDSUV), ZSPDIV (ISPEC2, IFLDSUV))

! DO JFLD = 1, IFLDSUV
!   ZSPVOR (:, JFLD) = VOR (JFLD)%V (:)
!   ZSPDIV (:, JFLD) = DIV (JFLD)%V (:)
! ENDDO

ELSE

  IFLDSUV = 0
  ALLOCATE (ZGPUV (0, IFLDSUV, 2, 0), ZSPVOR (0, 0), ZSPDIV (0, 0))

ENDIF

IF (PRESENT (GRID) .NEQV. PRESENT (SPEC)) STOP "GRID/SPEC"
IF (PRESENT (GRID) .NEQV. PRESENT (VSET)) STOP "GRID/VSET"

IF (PRESENT (GRID)) THEN

! IF ((SIZE (GRID) /= SIZE (SPEC)) .AND. (SIZE (GRID) /= SIZE (VSET))) THEN
!   PRINT *, " SIZE (GRID) = ", SIZE (GRID)
!   PRINT *, " SIZE (SPEC) = ", SIZE (SPEC)
!   PRINT *, " SIZE (VSET) = ", SIZE (VSET)
!   STOP 1
! ENDIF

! IPROMA = SIZE (GRID (1)%V, 1)
! IGPBLKS = SIZE (GRID (1)%V, 2)
! IFLDG = SIZE (GRID)

! ISPEC2 = SIZE (SPEC (1)%V, 1)
! IFLDS = SIZE (SPEC)

! ALLOCATE (ZGP (IPROMA, IFLDG, IGPBLKS), ZSPSCALAR (ISPEC2, IFLDS))

! DO JFLD = 1, IFLDS
!   ZSPSCALAR (:,JFLD) = SPEC (JFLD)%V (:)
! ENDDO

ELSE

  IFLDG = 0
  ALLOCATE (ZGP (0, IFLDG, 0), ZSPSCALAR (0, 0))

ENDIF

#ifdef UNDEF
CALL INV_TRANS (PSPVOR=ZSPVOR, PSPDIV=ZSPVIV, PGPUV=ZGPUV, KVSETUV=VSETUV, &
              & PSPSCALAR=ZSPSCALAR, PGP=ZGP, KVSETSC=VSET, KPROMA=IPROMA)
#endif

DO JFLD = 1, IFLDGUV
! U (JFLD)%V (:,:) = ZGPUV (:,JFLD,1,:)
! V (JFLD)%V (:,:) = ZGPUV (:,JFLD,2,:)
ENDDO

DO JFLD = 1, IFLDG
! GRID (JFLD)%V (:,:) = ZGP (:, JFLD, :)
ENDDO

END SUBROUTINE

END MODULE

PROGRAM MAIN

USE FIELD_MODULE
USE INV_TRANS_MODULE

INTEGER, PARAMETER :: NPRTRW = 5, NPRTRV = 3, MYSETW = 1, MYSETV = 1

INTEGER, PARAMETER :: NPROMA = 100, NFLEVG = 15, NGPBLKS = 10, NSPEC2 = 600
INTEGER :: NFLEVL 

CLASS (FIELD_3RB), POINTER :: GU, GV, GT, GQ
CLASS (FIELD_2RB), POINTER :: SVOR, SDIV, ST, SQ

CLASS (FIELD_2RB), POINTER :: GU1, GV1, GT1, GQ1
CLASS (FIELD_1RB), POINTER :: SVOR1, SDIV1, ST1, SQ1

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: U (:), V (:), GRID (:)
TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: VOR (:), DIV (:), SPEC (:)

INTEGER :: NBSETP
INTEGER, ALLOCATABLE :: NBSETLEV (:)
INTEGER, ALLOCATABLE :: VSETUV (:), VSET (:)

INTEGER :: JLEV

NBSETSP = 1

ALLOCATE (NBSETLEV (NFLEVG))

DO JLEV = 1, NFLEVG
  NBSETLEV (JLEV) = 1 + ((JLEV-1) * (NPRTRV)) / NFLEVG
ENDDO

NFLEVL = COUNT (NBSETLEV == MYSETV)

CALL FIELD_NEW (GU, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GV, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GT, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GQ, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])

CALL FIELD_NEW (SVOR, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SDIV, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (ST, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SQ, UBOUNDS=[NSPEC2, NFLEVL])

CALL FIELD_NEW (GU1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GV1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GT1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GQ1, UBOUNDS=[NPROMA, NGPBLKS])

CALL FIELD_NEW (SVOR1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW (SDIV1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW (ST1, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SQ1, UBOUNDS=[NSPEC2, NFLEVL])


! Create list arguments

CALL INV_TRANS (U=[B (GU), B (GU1)], VOR=[B (SVOR), B (SVOR1)], &
              & V=[B (GV), B (GV1)], DIV=[B (SDIV), B (SDIV1)], &
              & VSETUV=[NBSETLEV, NBSETSP], &
              & GRID=[B (GT), B (GQ), B (GT1), B (GQ1)], &
              & SPEC=[B (ST), B (SQ), B (ST1), B (SQ1)], &
              & VSET=[NBSETLEV, NBSETLEV, NBSETSP, NBSETSP])

#ifdef UNDEF

! Build list

U = [LG (GU), LG (GU1)]
V = [LG (GV), LG (GV1)]

VOR = [LS (SVOR), LS (SVOR1)]
DIV = [LS (SDIV), LS (SDIV1)]

VSETUV = [NBSETLEV, NBSETSP]

GRID = [LG (GT), LG (GQ), LG (GT1), LG (GQ1)]
SPEC = [LS (ST), LS (SQ), LS (ST1), LS (SQ1)]
VSET = [NBSETLEV, NBSETLEV, NBSETSP, NBSETSP]

CALL INV_TRANS (U=U, V=V, VOR=VOR, DIV=DIV, VSETUV=VSETUV, &
              & GRID=GRID, SPEC=SPEC, VSET=VSET)

! Build list in two steps

! First step : 3D fields

U = [LG (GU)]
V = [LG (GV)]

VOR = [LS (SVOR)]
DIV = [LS (SDIV)]

VSETUV = [NBSETLEV]

GRID = [LG (GT), LG (GQ)]
SPEC = [LS (ST), LS (SQ)]

! Append surface fields

U = [U, LG (GU1)]
V = [V, LG (GV1)]

VOR = [VOR, LS (SVOR1)]
DIV = [DIV, LS (SDIV1)]
VSETUV = [VSETUV, NBSETSP]

GRID = [GRID, LG (GT1), LG (GQ1)]
SPEC = [SPEC, LS (ST1), LS (SQ1)]

CALL INV_TRANS (U=U, V=V, VOR=VOR, DIV=DIV, VSETUV=VSETUV, &
              & GRID=GRID, SPEC=SPEC, VSET=VSET)

#endif

END 

